/** @format */

import { spawn } from "node:child_process";
import { readFile } from "node:fs/promises";
import path from "node:path";
import process from "node:process";

// Resolve paths relative to app root
const appRoot = process.cwd();
const apiConfigPath = path.join(appRoot, "src", "config", "api-version.ts");

// Parse command and remaining arguments from CLI
const [command, ...additionalArgs] = process.argv.slice(2);

if (!command) {
	throw new Error(
		"Usage: node ./scripts/wrangler-versioned.mjs <command> [args...]",
	);
}

// Extract the API version (e.g., "v0", "v1") â€” doubles as the wrangler env name.
// Auto-generated by sync-api-version.mjs during `pnpm deploy`
const configRaw = await readFile(apiConfigPath, "utf8");
const versionMatch = configRaw.match(/API_VERSION = "([^"]+)"/);
if (!versionMatch) {
	throw new Error(
		"Could not read API_VERSION from src/config/api-version.ts",
	);
}
const apiEnv = versionMatch[1];

// Check if user explicitly provided --env flag
// This allows overriding the derived API version environment
const envIndex = additionalArgs.indexOf("--env");
const explicitEnv =
	envIndex !== -1 && envIndex + 1 < additionalArgs.length ?
		additionalArgs[envIndex + 1]
	:	null;

// Remove --env from args to avoid duplication (we'll re-add it below)
let cleanArgs = [...additionalArgs];
if (envIndex !== -1) {
	cleanArgs.splice(envIndex, 2);
}

// Use explicit env if provided, otherwise use the derived API version env
// This ensures production deploys use the correct versioned environment
const selectedEnv = explicitEnv ?? apiEnv;

// Prepare base arguments: add --minify flag for deploy commands
const baseArgs = command === "deploy" ? [command, "--minify"] : [command];

// Build final argument list: base command + wrangler args + derived/explicit env
const allArgs = [...baseArgs, ...cleanArgs, "--env", selectedEnv];

// Spawn wrangler process with inherited stdio (shows output directly)
const child = spawn("wrangler", allArgs, {
	stdio: "inherit",
});

// Forward SIGINT (Ctrl+C) and SIGTERM to child process for graceful shutdown
process.on("SIGINT", () => {
	child.kill("SIGINT");
});
process.on("SIGTERM", () => {
	child.kill("SIGTERM");
});

// Exit wrapper with child's exit code
child.on("exit", (code, signal) => {
	process.exit(code ?? (signal ? 1 : 0));
});
